## 位运算

**0~n缺失的数字**

```python
def missingNumber(self, nums: List[int]) -> int:
        res = 0
        n = len(nums)
        for x in range(n):
            res = res ^ x ^ nums[x]
        res = res ^ n
        return res
```

**有序数组单一元素 只有一个元素出现了一次**

```
def singleNonDuplicate(self, nums: List[int]) -> int:
        res = 0
        for elem in nums:
            res = res ^ elem
        return res
```

**数组中数字出现的次数 只有两个数字出现了一次**

```
def singleNumbers(self, nums: List[int]) -> List[int]:
        bitmask = 0 # 保留了两个只出现一次数字的异或结果
        for elem in nums:
            bitmask = bitmask ^ elem
        bitmask = bitmask &(-bitmask) # 保留异或结果最右端的1，根据这个1把nums分成两组
        res = [0,0]
        for elem in nums:
            if elem & bitmask == 0:
                res[0] = res[0] ^ elem
            else:
                res[1] = res[1] ^ elem
        return res
```

**数组中数字出现的次数 只有一个数字出现一次，其他数字出现3次**

```python
def singleNumber(self, nums: List[int]) -> int:
        bitcount = 0
        res = 0
        for x in range(32):
            bitcount = sum([(num >> x)&1 for num in nums])
            if bitcount % 3:
                res = res | (1 << x) if x != 31 else res - (1 << x)
            #当i=31需要特殊处理，因为python没有有符号和无符号数的区别，最高位存放着就是2^n，因此需要最高位的时候，先右移动溢出，再用上一步的结果减去得到复数结果，如果是整数，不会有这个问题
        return res
```

**判断字符是否唯一（两个数字出现一次）**

```python
def isUnique(self, astr: str) -> bool:
        bitmask = 0
        for elem in astr:
            num = ord(elem)-ord('a')
            if bitmask & (1<<num) != 0:
                return False
            bitmask = bitmask | (1 << num)
        return True
```

