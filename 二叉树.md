## 二叉树

### 1、重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```python
# 根据前序遍历拿到根节点
# 根据根节点在中序遍历（没有重复数字）确定左右子树
# 递归的建立左右子树
def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return
        root       = TreeNode(preorder[0])
        index      = inorder.index(preorder[0])
        root.left  = self.buildTree(preorder[1:index+1], inorder[:index])
        root.right = self.buildTree(preorder[index+1:], inorder[index+1:])
        return root
```

### 2、树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

```python
def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        if not A or not B:
            return False
        def dfs(A, B):
            if not B:
                return True
            if not A:
                return False
            return A.val == B.val and dfs(A.left,B.left) and dfs(A.right,B.right)
        return dfs(A,B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right,B)
```

### 3、二叉树的镜像

```
def mirrorTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return 
        root.left,root.right = root.right,root.left
        self.mirrorTree(root.left)
        self.mirrorTree(root.right)
        return root
```

### 4、从上到下打印二叉树

```python
#BFS
def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res   = []
        while queue:
            cur_level  = []
            next_level = []
            for node in queue:
                cur_level.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            queue = next_level[:]
            res.append(cur_level[:])
        return res
```

```python
# 按照之字形打印
def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res   = []
        level = 1
        while queue:
            if level % 2 == 1:
                res.append([node.val for node in queue])
            else:
                ll = [node.val for node in queue]
                res.append(ll[::-1])
            temp = []
            for node in queue:
                if node.left:
                    temp.append(node.left)
                if node.right:
                    temp.append(node.right)
            queue  = temp[:]
            level += 1
        return res
```

