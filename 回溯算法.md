## 回溯算法

电话号码的字母数字组合

```python
def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        d = {2:"abc", 3:"def", 4:"ghi",
                5:"jkl", 6:"mno", 7:"pqrs",
                8:"tuv", 9:"wxyz"}
        def backtrack(res, s, digits, index):
            # 递归终止条件
            if len(s) == len(digits):
                res.append(s)
                return
            s_temp = d[int(digits[index])]
            for c in s_temp:
                #选择当前值
                s += c
                backtrack(res, s, digits, index+1)
                #回溯
                s = s[:-1]
            return
        res = []
        backtrack(res, "", digits, 0)
        return res
```

四数之和

```python
def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        if not nums:
            return []
        def backtrack(nums, res, path, k, target):
            if len(path) == k and sum(path) == target:
                res.append(path[:])
                return
            if len(path[:]) > k or not nums:
                return
            for x in range(len(nums)):
               
                if x > 0 and nums[x] == nums[x-1]:
                    continue
                # 加上最大的数补全4个都不够用，则肯定行不通
                elif sum(path) + (k-1-len(path))*nums[-1] + nums[x] < target:
                    continue
                # 加上当前最小的数补全大于target，直接跳出
                elif nums[x] * (k-len(path)) + sum(path) > target:
                    break      
                path.append(nums[x])
                backtrack(nums[x+1:], res, path, k, target)
                path.pop()
        res = []
        path = []
        k = 4
        nums.sort()
        backtrack(nums, res, path, k, target)
        return res
```

字符串全排列

```
def permutation(self, s: str) -> List[str]:
        def backtrack(s, path, visited, res):
            if len(path) == len(s):
                res.add(path)
                return
            for x in range(len(s)):
                if visited[x]:
                    continue

                visited[x] = True
                backtrack(s, path+s[x], visited, res)
                visited[x] = False
        visited = len(s) * [False]
        res = set()
        backtrack(s, '', visited, res)
        return list(res)
```

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

```
def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(res, n, k, start, temp):
            if k == 0:
                res.append(temp[:])
                return
            for i in range(start,n-k+2):
                temp.append(i)
                backtrack(res, n, k-1, i+1, temp)
                temp.pop()
        res = []
        backtrack(res, n, k, 1, [])
        return res
```

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

```
def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(res, path, candidates, target, start):
            if target == 0:
                res.append(path[:])
                return
            for x in range(start,len(candidates)):
                if target < candidates[x]:
                    continue
                path.append(candidates[x])
                backtrack(res, path, candidates, target-candidates[x], x)
                path.pop()
        res = []
        backtrack(res, [], candidates, target, 0)
        return res
```

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

    所有数字（包括目标数）都是正整数。
    解集不能包含重复的组合。 

```
def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(res, path, candidates,target, start):
            if target == 0:
                res.append(path[:])
                return
            for x in range(start, len(candidates)):
                if target < candidates[x]:
                    continue
                if x > start and (candidates[x] == candidates[x-1]):
                    continue
                path.append(candidates[x])
                backtrack(res, path, candidates, target-candidates[x], x+1)
                path.pop()
        res = []
        candidates.sort()
        backtrack(res, [], candidates, target, 0)
        return res
```

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

    所有数字都是正整数。
    解集不能包含重复的组合。 

```
def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        def backtrack(res, path, k, start, n):
            if len(path) == k or n <= 0:
                if len(path) == k and n == 0:
                    res.append(path[:])
                    return
            for x in range(start, 10):
                path.append(x)
                backtrack(res, path, k, x+1, n-x)
                path.pop()
        res = []
        backtrack(res, [], k, 1, n)
        return res
```

机器人运动路径，若存在多条，返回其中一条路径，或者矩阵中是否存在某条路径，应该用回溯法比较合适。路径条数，最小路径和，是否存在路径，动态规划。满足最小和路径的，回溯动态规划都可以。

```python
def pathWithObstacles(self, obstacleGrid: List[List[int]]) -> List[List[int]]:
        def dfs(x, y, visited, obstacleGrid):
            if x >= len(obstacleGrid) or y >= len(obstacleGrid[0]) or obstacleGrid[x][y] == 1:
                return 
            #print([x,y])
            if visited[x][y]:
                return
            visited[x][y] = True
            temp.append([x,y])
            #print(temp)
            if x== len(obstacleGrid)-1 and y == len(obstacleGrid[0])-1:
                res[:] = temp[:]
                return   
            dfs(x, y+1, visited, obstacleGrid)
            dfs(x+1, y, visited, obstacleGrid)
            temp.pop()
        visited = [[False]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]
        temp = []
        res  = []
        dfs(0, 0, visited, obstacleGrid)
        return res
```

